use crate::parser::Node;

use std::fs::File;
use std::io::Write;
use std::path::PathBuf;

const START: &str = r#"/* This file was generated by bfc-rs (https://github.com/ceilingfans/bfc-rs) */
#include <stdio.h>

int main()
{
    char arr[30000] = {0}; char* ptr = arr;
"#;

pub struct Transpiler {
    pub tree: Vec<Node>,
    source: String,
    out: File,
    nesting: usize,
}

impl Transpiler {
    pub fn new(tree: Vec<Node>, out: PathBuf) -> Self {
        let file = File::create(out).expect("failed to create file");

        Transpiler {
            tree,
            source: String::from(START),
            out: file,
            nesting: 1,
        }
    }

    fn append_to_source(&mut self, s: impl AsRef<str>) {
        let string = s.as_ref().to_string();
        let fmt_string = format!("{}{}\n", "    ".repeat(self.nesting), string);
        self.source.push_str(fmt_string.as_str());
    }

    fn write(&mut self, nest: Option<Vec<Node>>) {
        let to_iterate: Vec<Node> = if let Some(tokens) = nest {
            tokens
        } else {
            self.tree.to_vec()
        };

        for tok in to_iterate {
            match tok {
                Node::CellShift { amount, .. } => {
                    self.append_to_source(format!("*ptr += {};", amount))
                }
                Node::PointerShift { amount, .. } => {
                    self.append_to_source(format!("ptr += {};", amount))
                }
                Node::Read { .. } => self.append_to_source("*ptr = getchar();"),
                Node::Write { .. } => self.append_to_source("putchar(*ptr);"),
                Node::Loop { body, .. } => {
                    self.append_to_source("while (*ptr)");
                    self.append_to_source("{");
                    self.nesting += 1;
                    self.write(Some(body));
                    self.nesting -= 1;
                    self.append_to_source("}");
                }
                Node::Set { amount, .. } => self.append_to_source(format!("*ptr = {};", amount)),
            }
        }
    }

    pub fn transpile(&mut self) {
        println!("info: transpiling to c code");
        self.write(None);
        self.append_to_source("return 0;");
        self.nesting -= 1;
        self.append_to_source("}");
        println!("info: writing to c file");
        self.out
            .write(self.source.as_bytes())
            .expect("failed to write file");
        println!("info: completed transpilation process")
    }
}
